<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echo Dungeon - Voice Adventure</title>
    <style>
        body { margin: 0; padding: 0; background: #000; color: #fff; font-size: 0; overflow: hidden; }
        #voiceActivator { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
                         background: transparent; border: none; cursor: pointer; z-index: 1000; }
        .sr-only { position: absolute !important; left: -10000px; }
    </style>
</head>
<body>
    <button id="voiceActivator" aria-label="Click anywhere to activate voice">
        <span class="sr-only">Echo Dungeon - Click anywhere to speak</span>
    </button>
    <div id="gameStatus" role="status" aria-live="assertive" class="sr-only">Voice game loaded</div>

    <script>
        class SpeechManager {
            constructor() {
                this.synth = window.speechSynthesis;
                this.voices = [];
                this.currentVoice = null;
                this.isInitialized = false;
                this.settings = { rate: 1.3, pitch: 1.0, volume: 1.0, lang: 'en-US' };
                this.init();
            }
            
            init() {
                if (this.synth) {
                    this.loadVoices();
                } else {
                    alert('Speech not supported. Please use Chrome or Edge.');
                }
            }
            
            loadVoices() {
                this.voices = this.synth.getVoices();
                if (this.voices.length === 0) {
                    this.synth.addEventListener('voiceschanged', () => {
                        this.voices = this.synth.getVoices();
                        this.selectBestVoice();
                    });
                } else {
                    this.selectBestVoice();
                }
            }
            
            selectBestVoice() {
                const preferred = ['Microsoft Zira', 'Google US English Female', 'Karen', 'Alex'];
                for (const p of preferred) {
                    const voice = this.voices.find(v => v.name.includes(p));
                    if (voice) { this.currentVoice = voice; break; }
                }
                if (!this.currentVoice) {
                    this.currentVoice = this.voices.find(v => v.lang.includes('en')) || this.voices[0];
                }
                this.isInitialized = true;
            }
            
            speak(text, options = {}) {
                return new Promise((resolve) => {
                    if (!this.synth || !this.isInitialized) {
                        setTimeout(() => this.speak(text, options).then(resolve), 200);
                        return;
                    }
                    
                    this.synth.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = options.rate || this.settings.rate;
                    utterance.pitch = options.pitch || this.settings.pitch;
                    utterance.volume = options.volume || this.settings.volume;
                    if (this.currentVoice) utterance.voice = this.currentVoice;
                    
                    utterance.onend = () => resolve();
                    utterance.onerror = () => resolve();
                    this.synth.speak(utterance);
                });
            }
            
            stop() { if (this.synth) this.synth.cancel(); }
            isSpeaking() { return this.synth ? this.synth.speaking : false; }
        }

        class GameState {
            constructor() {
                this.player = { health: 100, maxHealth: 100, class: null, level: 1, inventory: [], location: 'entrance' };
                this.gameStarted = false;
                this.currentRoom = null;
                this.rooms = {
                    entrance: {
                        description: "You stand at the entrance of an ancient dungeon. Stone passages lead north and east into darkness.",
                        exits: { north: 'corridor', east: 'chamber' },
                        items: ['torch'], monsters: []
                    },
                    corridor: {
                        description: "A narrow stone corridor with ancient runes. You can go south to entrance or north deeper.",
                        exits: { south: 'entrance', north: 'treasury' },
                        items: ['health potion'], monsters: ['goblin']
                    },
                    chamber: {
                        description: "A circular chamber with pale light from above. Passages lead west to entrance and north.",
                        exits: { west: 'entrance', north: 'boss_room' },
                        items: ['mana crystal', 'old sword'], monsters: ['skeleton']
                    },
                    treasury: {
                        description: "A treasure chamber gleaming with gold. This is the dungeon's treasure vault.",
                        exits: { south: 'corridor' },
                        items: ['treasure chest', 'magic scroll'], monsters: ['guardian']
                    },
                    boss_room: {
                        description: "The final throne room where dark magic pulses. This is the dungeon master's lair.",
                        exits: { south: 'chamber' },
                        items: ['legendary crown'], monsters: ['dungeon overlord']
                    }
                };
            }
        }

        const speechManager = new SpeechManager();
        const gameState = new GameState();
        let recognition = null;
        let isListening = false;
        let gameInitialized = false;

        async function speakGameText(message) {
            await speechManager.speak(message);
        }

        async function speakQuick(message) {
            await speechManager.speak(message, { rate: speechManager.settings.rate * 1.2 });
        }

        async function speakImportant(message) {
            await speechManager.speak(message, { rate: speechManager.settings.rate * 0.9 });
        }

        function initializeVoiceRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert("Voice recognition requires Chrome, Edge, or Safari.");
                return false;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onstart = () => { isListening = true; };
            recognition.onresult = (event) => {
                const command = event.results[0][0].transcript.toLowerCase().trim();
                processCommand(command);
            };
            recognition.onerror = (event) => {
                isListening = false;
                if (event.error === 'no-speech') {
                    setTimeout(() => speakQuick("I'm listening. Please speak."), 500);
                } else if (event.error === 'not-allowed') {
                    alert("Please allow microphone access.");
                }
            };
            recognition.onend = () => {
                isListening = false;
                setTimeout(() => {
                    if (gameInitialized && !isListening) startListening();
                }, 2000);
            };
            return true;
        }

        function startListening() {
            if (recognition && !isListening) {
                try { recognition.start(); } catch (e) {
                    setTimeout(() => { try { recognition.start(); } catch (e) {} }, 1000);
                }
            }
        }
        // Add this to the end of the <script> section in Part 1

async function processCommand(command) {
    if (!gameState.gameStarted) {
        if (command.includes('warrior')) await startGame('warrior');
        else if (command.includes('mage') || command.includes('wizard')) await startGame('mage');
        else if (command.includes('rogue') || command.includes('thief')) await startGame('rogue');
        else await speakGameText("Choose your class: warrior, mage, or rogue.");
        return;
    }

    // Stop commands
    if (command.includes('stop talking') || command.includes('be quiet')) {
        speechManager.stop();
        await new Promise(resolve => setTimeout(resolve, 500));
        await speakQuick("Speech stopped. Say continue when ready.");
        return;
    }

    // Repeat commands
    if (command.includes('repeat') || command.includes('again') || command === 'what') {
        await describeLocation();
        return;
    }

    // Movement
    const directions = ['north', 'south', 'east', 'west', 'up', 'down', 'left', 'right', 'forward', 'back'];
    for (const dir of directions) {
        if (command.includes(dir)) {
            const mappedDir = mapDirection(dir);
            await movePlayer(mappedDir);
            return;
        }
    }

    // Combat
    if (command.includes('attack') || command.includes('fight') || command.includes('battle')) {
        await handleCombat();
        return;
    }

    // Search
    if (command.includes('search') || command.includes('look') || command.includes('explore')) {
        await searchRoom();
        return;
    }

    // Inventory
    if (command.includes('inventory') || command.includes('items') || command.includes('what do i have')) {
        await showInventory();
        return;
    }

    // Use items
    if (command.includes('use') || command.includes('drink') || command.includes('consume')) {
        await useItem(command);
        return;
    }

    // Status
    if (command.includes('status') || command.includes('health') || command.includes('stats')) {
        await showStatus();
        return;
    }

    // Location
    if (command.includes('where am i') || command.includes('location') || command.includes('exits')) {
        await describeLocation();
        return;
    }

    // Help
    if (command.includes('help') || command.includes('commands')) {
        await showHelp();
        return;
    }

    // Restart
    if (command.includes('restart') || command.includes('new game')) {
        await restartGame();
        return;
    }

    await speakQuick(`I didn't understand "${command}". Say help for commands.`);
}

function mapDirection(direction) {
    const dirMap = {
        'up': 'north', 'forward': 'north',
        'down': 'south', 'back': 'south',
        'right': 'east', 'left': 'west'
    };
    return dirMap[direction] || direction;
}

async function startGame(playerClass) {
    gameState.player.class = playerClass;
    gameState.gameStarted = true;
    gameState.currentRoom = 'entrance';
    
    const descriptions = {
        warrior: "You are now a mighty warrior with superior combat skills.",
        mage: "You are now a powerful mage wielding magical forces.",
        rogue: "You are now a cunning rogue with stealth abilities."
    };
    
    await speakImportant(`${descriptions[playerClass]} Your adventure begins!`);
    await describeLocation();
}

async function movePlayer(direction) {
    const currentRoom = gameState.rooms[gameState.currentRoom];
    
    if (!currentRoom.exits[direction]) {
        const exits = Object.keys(currentRoom.exits).join(', ');
        await speakQuick(`Cannot go ${direction}. Available: ${exits}.`);
        return;
    }
    
    gameState.currentRoom = currentRoom.exits[direction];
    gameState.player.location = gameState.currentRoom;
    await speakGameText(`You move ${direction}.`);
    await new Promise(resolve => setTimeout(resolve, 800));
    await describeLocation();
}

async function describeLocation() {
    const room = gameState.rooms[gameState.currentRoom];
    let description = room.description;
    
    if (room.items.length > 0) {
        description += ` Items here: ${room.items.join(', ')}.`;
    }
    
    if (room.monsters.length > 0) {
        description += ` Warning! A ${room.monsters[0]} blocks your path!`;
    }
    
    const exits = Object.keys(room.exits);
    description += ` Exits: ${exits.join(', ')}.`;
    
    await speakImportant(description);
}

async function handleCombat() {
    const room = gameState.rooms[gameState.currentRoom];
    
    if (room.monsters.length === 0) {
        await speakQuick("No enemies here to fight.");
        return;
    }
    
    const monster = room.monsters[0];
    await speakGameText(`Fighting the ${monster}!`);
    
    const playerRoll = Math.floor(Math.random() * 20) + 1;
    const monsterRoll = Math.floor(Math.random() * 20) + 1;
    
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    if (playerRoll >= monsterRoll) {
        await speakQuick(`Victory! You rolled ${playerRoll}, ${monster} rolled ${monsterRoll}.`);
        room.monsters.splice(0, 1);
        gameState.player.level++;
        await speakGameText("Monster defeated! Path clear.");
    } else {
        await speakQuick(`Defeat! You ${playerRoll}, ${monster} ${monsterRoll}.`);
        gameState.player.health -= 25;
        
        if (gameState.player.health <= 0) {
            await handleDeath();
        } else {
            await speakGameText(`Damage taken! Health: ${gameState.player.health}. Monster still blocks way.`);
        }
    }
}

async function handleDeath() {
    await speakImportant("You have fallen! But heroes don't stay dead.");
    gameState.player.health = gameState.player.maxHealth;
    gameState.currentRoom = 'entrance';
    await speakGameText("You awaken at entrance, fully healed.");
    await describeLocation();
}

async function searchRoom() {
    const room = gameState.rooms[gameState.currentRoom];
    
    if (room.items.length > 0) {
        const item = room.items[0];
        gameState.player.inventory.push(item);
        room.items.splice(0, 1);
        await speakGameText(`Found ${item}! Added to inventory.`);
    } else {
        await speakQuick("Search found nothing.");
    }
}

async function showInventory() {
    if (gameState.player.inventory.length === 0) {
        await speakQuick("Inventory empty.");
    } else {
        await speakGameText(`You have: ${gameState.player.inventory.join(', ')}.`);
    }
}

async function useItem(command) {
    if (gameState.player.inventory.length === 0) {
        await speakQuick("No items to use.");
        return;
    }
    
    let targetItem = null;
    for (const item of gameState.player.inventory) {
        if (command.includes(item.toLowerCase())) {
            targetItem = item;
            break;
        }
    }
    
    if (!targetItem) {
        if (command.includes('potion') || command.includes('health')) {
            targetItem = gameState.player.inventory.find(item => item.includes('potion'));
        }
    }
    
    if (!targetItem) {
        await speakQuick("Which item? Say inventory first.");
        return;
    }
    
    const index = gameState.player.inventory.indexOf(targetItem);
    gameState.player.inventory.splice(index, 1);
    
    if (targetItem.includes('health') || targetItem.includes('potion')) {
        const oldHealth = gameState.player.health;
        gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + 40);
        const heal = gameState.player.health - oldHealth;
        await speakGameText(`Used ${targetItem}. Restored ${heal} health. Health: ${gameState.player.health}.`);
    } else {
        await speakGameText(`Used ${targetItem}.`);
    }
}

async function showStatus() {
    await speakGameText(`Health: ${gameState.player.health}. Level ${gameState.player.level} ${gameState.player.class}. Location: ${gameState.player.location}.`);
}

async function showHelp() {
    await speakImportant("Commands: north south east west for movement. attack or fight for combat. search or explore for items. inventory for items. use health potion. status for health. where am i for location. repeat to hear again. help for this message.");
}

async function restartGame() {
    speechManager.stop();
    gameState.gameStarted = false;
    gameState.player = { health: 100, maxHealth: 100, class: null, level: 1, inventory: [], location: 'entrance' };
    gameState.currentRoom = null;
    await speakImportant("Game restarted! Choose: warrior, mage, or rogue.");
}
async function initializeGame() {
    if (initializeVoiceRecognition()) {
        gameInitialized = true;
        await new Promise(resolve => setTimeout(resolve, 1500));
        await speakImportant("Welcome to Echo Dungeon! Voice-controlled adventure. Choose your class: warrior, mage, or rogue.");
        startListening();
    }
}

// Event listeners
document.addEventListener('click', () => { if (!gameInitialized) initializeGame(); });
document.addEventListener('keydown', (e) => { if (!gameInitialized) { e.preventDefault(); initializeGame(); } });
window.addEventListener('load', () => { setTimeout(() => { if (!gameInitialized) initializeGame(); }, 2000); });
    </script>
</body>
</html>
