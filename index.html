<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Echo Dungeon</title>
  <style>
    body { margin: 0; padding: 0; background: #111; }
    #micButton {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: #222; border: none; cursor: pointer; transition: background 0.3s;
    }
    #micButton:active { background: #444; }
    .listening { background: #004400 !important; }
    .start-button { background: #000044 !important; }
    #textDisplay {
      position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
      overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0;
    }
  </style>
</head>
<body>
  <div id="textDisplay"></div>
  <button id="micButton" class="start-button" onclick="handleClick()" aria-label="Voice command button"></button>
  <script>
    const micButton = document.getElementById('micButton');
    const textDisplay = document.getElementById('textDisplay');
    function displayText(text) { textDisplay.innerHTML = text; }

    let browserSupport = {
      speechSynthesis: false,
      speechRecognition: false,
      https: false
    };

    function checkBrowserSupport() {
      browserSupport.https = window.location.protocol === 'https:' || window.location.hostname === 'localhost';
      browserSupport.speechSynthesis = !!(window.speechSynthesis && window.SpeechSynthesisUtterance);
      browserSupport.speechRecognition = !!(window.webkitSpeechRecognition || window.SpeechRecognition);
    }

    const game = {
      player: {
        class: "", level: 1, health: 100, maxHealth: 100, mana: 50, maxMana: 50,
        gold: 25, inventory: [], position: { x: 2, y: 2 }, xp: 0
      },
      dungeon: { grid: {}, size: 6, secretRoom: null, hasSecretRoom: false, currentLevel: 1 },
      currentRoom: null, combat: null, listening: false, started: false,
      needsClass: true, initialized: false, phase: 'init'
    };

    const classes = {
      warrior: {
        name: 'Warrior', health: 120, maxHealth: 120, mana: 30, maxMana: 30, gold: 50,
        items: ['Iron Sword', 'Health Potion', 'Health Potion', 'Leather Armor'],
        special: { name: 'Power Strike', damage: 40, cost: 15, type: 'damage' }
      },
      mage: {
        name: 'Mage', health: 80, maxHealth: 80, mana: 100, maxMana: 100, gold: 75,
        items: ['Magic Staff', 'Mana Potion', 'Health Potion', 'Cloth Robes'],
        special: { name: 'Fireball', damage: 30, cost: 20, type: 'damage' }
      },
      rogue: {
        name: 'Rogue', health: 100, maxHealth: 100, mana: 60, maxMana: 60, gold: 100,
        items: ['Steel Dagger', 'Lockpicks', 'Health Potion', 'Studded Leather'],
        special: { name: 'Backstab', damage: 35, cost: 25, type: 'damage' }
      }
    };

    const rings = [
      { name: 'Ring of Minor Health', effect: '+10 Max Health', stat: 'maxHealth', value: 10 },
      { name: 'Ring of Minor Mana', effect: '+10 Max Mana', stat: 'maxMana', value: 10 },
      { name: 'Ring of Protection', effect: '+1 Defense', stat: 'defense', value: 1 }
    ];

    const shopInventory = [
      { name: 'Health Potion', price: 15, type: 'consumable' },
      { name: 'Mana Potion', price: 20, type: 'consumable' },
      { name: 'Ring of Minor Health', price: 100, type: 'ring' },
      { name: 'Ring of Minor Mana', price: 100, type: 'ring' },
      { name: 'Manual of Health', price: 250, type: 'manual', stat: 'maxHealth', value: 20, usageLimit: 1 },
      { name: 'Manual of Mana', price: 250, type: 'manual', stat: 'maxMana', value: 20, usageLimit: 1 }
    ];

    function speak(text, callback) {
      displayText(text);
      if (!browserSupport.speechSynthesis) {
        if (callback) setTimeout(callback, 2000);
        return;
      }
      try {
        speechSynthesis.cancel();
        setTimeout(() => {
          const utterance = new SpeechSynthesisUtterance(text.replace(/<[^>]*>/g, ""));
          utterance.rate = 0.8;
          if (callback) {
            utterance.onend = callback;
            utterance.onerror = callback;
          }
          speechSynthesis.speak(utterance);
        }, 100);
      } catch (error) {
        if (callback) setTimeout(callback, 2000);
      }
    }

    function speakSequence(messages, callback) {
      if (messages.length === 0) {
        if (callback) callback();
        return;
      }
      const [first, ...rest] = messages;
      speak(first, () => {
        if (rest.length > 0) {
          setTimeout(() => speakSequence(rest, callback), 500);
        } else if (callback) {
          callback();
        }
      });
    }

    let recognition = null;
    function startListening() {
      if (!browserSupport.speechRecognition || !browserSupport.https) {
        speak('Voice recognition requires HTTPS and a compatible browser.');
        return;
      }
      if (game.listening) { stopListening(); return; }
      try {
        const Recognition = window.webkitSpeechRecognition || window.SpeechRecognition;
        recognition = new Recognition();
        recognition.continuous = false;
        recognition.lang = 'en-US';
        recognition.onstart = () => {
          game.listening = true;
          micButton.classList.add('listening');
        };
        recognition.onresult = (event) => {
          const command = event.results[0][0].transcript.toLowerCase().trim();
          displayText(`You said: "${command}"`);
          stopListening();
          setTimeout(() => processCommand(command), 500);
        };
        recognition.onerror = (event) => {
          stopListening();
          if (event.error !== 'no-speech' && event.error !== 'aborted') {
            speak('Voice error. Try again.');
          }
        };
        recognition.onend = () => stopListening();
        recognition.start();
      } catch (error) {
        speak('Failed to start voice recognition.');
        stopListening();
      }
    }

    function stopListening() {
      game.listening = false;
      micButton.classList.remove('listening');
      if (recognition) {
        try { recognition.stop(); } catch (e) {}
        recognition = null;
      }
    }

    function handleClick() {
      if (!game.initialized) {
        initializeGame();
      } else {
        startListening();
      }
    }

    function initializeGame() {
      game.initialized = true;
      micButton.classList.remove('start-button');
      speak("Welcome to Echo Dungeon. Say load game to continue, or choose your class: warrior, mage, or rogue.");
    }

    // Next: selectClass, generateDungeon, move, describeRoom, and more in Part 2...function selectClass(className) {
      function selectClass(className) {
      const classData = classes[className];
      game.player.class = className;
      game.player.health = classData.health;
      game.player.maxHealth = classData.maxHealth;
      game.player.mana = classData.mana;
      game.player.maxMana = classData.maxMana;
      game.player.gold = classData.gold;
      game.player.inventory = [...classData.items];
      game.needsClass = false;
      game.started = true;
      game.phase = 'exploration';
      generateDungeon();
      speakSequence([
        `You are now a ${classData.name}.`,
        `Health: ${classData.health}.`,
        `Mana: ${classData.mana}.`,
        `Gold: ${classData.gold}.`,
        'Your adventure begins!'
      ], () => setTimeout(() => describeRoom(), 1000));
    }

    function generateDungeon() {
      const size = game.dungeon.size;
      const centerX = Math.floor(size / 2);
      const centerY = Math.floor(size / 2);
      game.dungeon.grid = {};
      for (let x = 0; x < size; x++) {
        for (let y = 0; y < size; y++) {
          const key = `${x},${y}`;
          const distance = Math.abs(x - centerX) + Math.abs(y - centerY);
          let room = { visited: false, searched: false, hasChest: false };
          if (x === centerX && y === centerY) {
            game.dungeon.grid[key] = { type: 'entrance', description: 'the entrance. Cold stone walls surround you.', hasEnemy: false, ...room };
          } else if (x === 0 && y === 0) {
            game.dungeon.grid[key] = { type: 'boss', description: 'the boss chamber. A powerful presence awaits.', hasEnemy: true, hasChest: true, enemy: { name: 'Dragon', health: 150, damage: 30, gold: 50, xp: 100, fleeChance: 0.1 }, ...room };
          } else if (distance === 1) {
            game.dungeon.grid[key] = { type: 'treasure', description: 'a treasure room. Something glints in the darkness.', hasEnemy: false, hasChest: true, ...room };
          } else if (distance === 2) {
            const isEnemy = Math.random() < 0.6;
            if (isEnemy) {
              const enemyType = Math.random() < 0.7 ? 'goblin' : 'skeleton';
              game.dungeon.grid[key] = { type: 'enemy', description: 'a dark chamber. You sense danger.', hasEnemy: true, hasChest: Math.random() < 0.3, enemy: { ...enemies[enemyType] }, ...room };
            } else {
              game.dungeon.grid[key] = { type: 'treasure', description: 'a treasure room. Something glints in the darkness.', hasEnemy: false, hasChest: true, ...room };
            }
          } else {
            game.dungeon.grid[key] = { type: 'empty', description: 'an empty chamber. Dust covers the floor.', hasEnemy: false, hasChest: Math.random() < 0.2, ...room };
          }
        }
      }
      if (Math.random() < 0.3) game.dungeon.hasSecretRoom = true;
      game.player.position = { x: centerX, y: centerY };
      game.currentRoom = game.dungeon.grid[`${centerX},${centerY}`];
    }

    function move(direction) {
      const { x, y } = game.player.position;
      let newX = x, newY = y;
      if (direction === 'north') newY--;
      else if (direction === 'south') newY++;
      else if (direction === 'east') newX++;
      else if (direction === 'west') newX--;
      if (newX < 0 || newX >= game.dungeon.size || newY < 0 || newY >= game.dungeon.size) {
        speak('You cannot go that way. There is a solid wall.');
        return;
      }
      game.player.position = { x: newX, y: newY };
      const key = `${newX},${newY}`;
      game.currentRoom = game.dungeon.grid[key];
      game.currentRoom.visited = true;
      describeRoom();
    }

    function describeRoom() {
      const room = game.currentRoom;
      const messages = [`You are in ${room.description}`];
      if (room.hasEnemy && room.enemy && room.enemy.health > 0) {
        messages.push(`A ${room.enemy.name} blocks your path!`);
        speakSequence(messages, () => setTimeout(() => startCombat(room.enemy), 1000));
      } else {
        if (room.hasChest && !room.searched) messages.push('You see a chest here.');
        if (!room.searched) messages.push('You could search this room.');
        messages.push('Which direction will you go?');
        speakSequence(messages);
      }
    }

    function startCombat(enemy) {
      game.combat = { enemy: { ...enemy }, playerDefending: false };
      game.phase = 'combat';
      speakSequence([
        'Combat begins!',
        `${enemy.name} has ${enemy.health} health.`,
        'What will you do? Say attack, defend, special, use potion, or flee.'
      ]);
    }

    function playerAttack() {
      const damage = 15 + Math.floor(Math.random() * 15);
      game.combat.enemy.health -= damage;
      speakSequence([
        `You attack for ${damage} damage!`,
        `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
      ], () => {
        if (game.combat.enemy.health <= 0) setTimeout(() => combatVictory(), 1000);
        else setTimeout(() => enemyTurn(), 1000);
      });
    }

    function playerDefend() {
      game.combat.playerDefending = true;
      speak('You raise your guard.', () => setTimeout(() => enemyTurn(), 1000));
    }

    function playerSpecial() {
      const classData = classes[game.player.class];
      const special = classData.special;
      if (game.player.mana < special.cost) {
        speak(`Not enough mana. You need ${special.cost}.`);
        return;
      }
      game.player.mana -= special.cost;
      game.combat.enemy.health -= special.damage;
      speakSequence([
        `You use ${special.name}!`,
        `${special.damage} damage!`,
        `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
      ], () => {
        if (game.combat.enemy.health <= 0) setTimeout(() => combatVictory(), 1000);
        else setTimeout(() => enemyTurn(), 1000);
      });
    }

    // Potion logic, ring equip, shop, save/load, level-up, and game over follow in next block...function enemyTurn() {
      let damage = game.combat.enemy.damage;
      if (game.combat.playerDefending) {
        damage = Math.floor(damage * 0.5);
        game.combat.playerDefending = false;
      }
      game.player.health -= damage;
      speakSequence([
        `${game.combat.enemy.name} attacks for ${damage} damage!`,
        `Your health: ${Math.max(0, game.player.health)}.`
      ], () => {
        if (game.player.health <= 0) {
          setTimeout(() => gameOver(), 1000);
        } else {
          setTimeout(() => speak('What will you do?'), 500);
        }
      });
    }

    function combatVictory() {
      const gold = game.combat.enemy.gold;
      const xp = game.combat.enemy.xp;
      game.player.gold += gold;
      const leveled = gainXP(xp);
      if (game.currentRoom.enemy) game.currentRoom.enemy.health = 0;
      let messages = [
        `${game.combat.enemy.name} defeated!`,
        `You gain ${gold} gold and ${xp} experience points!`
      ];
      if (leveled) messages.push('You leveled up!');
      speakSequence(messages, () => {
        game.combat = null;
        game.phase = 'exploration';
        if (game.currentRoom.type === 'boss') {
          setTimeout(() => dungeonComplete(), 1500);
        } else {
          setTimeout(() => speak('What will you do next?'), 1000);
        }
      });
    }

    function gainXP(amount) {
      const neededXP = game.player.level * 100;
      game.player.xp += amount;
      if (game.player.xp >= neededXP) {
        game.player.xp -= neededXP;
        levelUp();
        return true;
      }
      return false;
    }

    function levelUp() {
      game.player.level++;
      let healthGain = 0, manaGain = 0;
      if (game.player.class === 'warrior') { healthGain = 20; manaGain = 5; }
      else if (game.player.class === 'mage') { healthGain = 10; manaGain = 20; }
      else if (game.player.class === 'rogue') { healthGain = 15; manaGain = 10; }
      game.player.maxHealth += healthGain;
      game.player.health = game.player.maxHealth;
      game.player.maxMana += manaGain;
      game.player.mana = game.player.maxMana;
      speakSequence([
        `Congratulations! You have reached Level ${game.player.level}!`,
        `Your Max Health increased by ${healthGain} to ${game.player.maxHealth}.`,
        `Your Max Mana increased by ${manaGain} to ${game.player.maxMana}.`,
        'Your health and mana have been fully restored!'
      ]);
    }

    function dungeonComplete() {
      levelUp();
      speakSequence([
        'You defeated the mighty Dragon!',
        'You feel a surge of power, leveling up from this ultimate battle!',
        'The path ahead is now open.',
        `Final gold: ${game.player.gold}.`,
        'You are victorious for now! Find the stairs to continue your journey.'
      ]);
    }

    function gameOver() {
      speakSequence([
        'You have been defeated.',
        'Your adventure ends here.',
        `Final gold: ${game.player.gold}.`,
        'Game over.'
      ]);
    }

    function meditate() {
      if (game.combat) {
        speak('You cannot meditate during combat!');
        return;
      }
      const manaRestored = 10;
      const previousMana = game.player.mana;
      if (game.player.mana === game.player.maxMana) {
        speak('You are already at full mana.');
        return;
      }
      game.player.mana = Math.min(game.player.maxMana, game.player.mana + manaRestored);
      const actualRestored = game.player.mana - previousMana;
      speak(`You meditate for a moment and restore ${actualRestored} mana. Current mana: ${game.player.mana}.`);
    }

    function saveGame() {
      try {
        localStorage.setItem('echoDungeonSave', JSON.stringify(game));
        speak('Game saved successfully. You can load it next time by saying "load game".');
      } catch (e) {
        speak('Error saving game. Your browser may not support local storage.');
      }
    }

    function loadGame() {
      const savedData = localStorage.getItem('echoDungeonSave');
      if (savedData) {
        try {
          const loadedGame = JSON.parse(savedData);
          Object.assign(game, loadedGame);
          const key = `${game.player.position.x},${game.player.position.y}`;
          game.currentRoom = game.dungeon.grid[key];
          game.initialized = true;
          game.started = true;
          game.needsClass = false;
          game.phase = game.combat ? 'combat' : 'exploration';
          micButton.classList.remove('start-button');
          speak(`Game loaded successfully. You are on Level ${game.dungeon.currentLevel} at coordinates ${game.player.position.x}, ${game.player.position.y}.`, () => {
            if (game.combat) {
              speak(`You are still in combat with a ${game.combat.enemy.name}.`);
            } else {
              describeRoom();
            }
          });
        } catch (e) {
          speak('Error loading game data. The save file might be corrupted.');
        }
      } else {
        speak('No saved game found.');
      }
    }

    function characterStatus() {
      const classData = classes[game.player.class];
      const special = classData.special;
      speakSequence([
        `Class: ${classData.name}.`,
        `Health: ${game.player.health} of ${game.player.maxHealth}.`,
        `Mana: ${game.player.mana} of ${game.player.maxMana}.`,
        `Special ability: ${special.name}. Costs ${special.cost} mana.`,
        `Gold: ${game.player.gold}.`
      ]);
    }

    function listInventory() {
      if (game.player.inventory.length === 0) {
        speak(`Empty inventory. Gold: ${game.player.gold}.`);
      } else {
        const healthPotions = game.player.inventory.filter(i => i === 'Health Potion').length;
        const manaPotions = game.player.inventory.filter(i => i === 'Mana Potion').length;
        const otherItems = game.player.inventory.filter(i => i !== 'Health Potion' && i !== 'Mana Potion');
        const messages = ['Inventory:'];
        if (healthPotions > 0) messages.push(`${healthPotions} health potion${healthPotions > 1 ? 's' : ''}.`);
        if (manaPotions > 0) messages.push(`${manaPotions} mana potion${manaPotions > 1 ? 's' : ''}.`);
        if (otherItems.length > 0) messages.push(otherItems.join(', ') + '.');
        messages.push(`Gold: ${game.player.gold}.`);
        speakSequence(messages);
      }
    }

    function listCommands() {
      speakSequence([
        'Available commands:',
        'Move: north, south, east, west.',
        'Combat: attack, defend, special, use potion, flee.',
        'Explore: look, search, open chest, meditate.',
        'Inventory: inventory, wear ring, status.',
        'Shop: shop list, buy [item name].',
        'Save/load: save game, load game.'
      ]);
    }
  </script>
</body>
</html>



